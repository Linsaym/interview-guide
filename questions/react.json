[
  {
    "id": 10,
    "question": "Чем управляемые (controlled) компоненты отличаются от неуправляемых (uncontrolled) в React?",
    "answer": "Управляемые компоненты получают текущее значение и коллбэк для изменений через props (значение контролируется React). Неуправляемые используют ref для доступа к DOM-элементу напрямую (значение хранится в DOM). Управляемые рекомендуются для форм, так как дают больше контроля.",
    "category": "React",
    "level": "junior",
    "tags": [
      "components",
      "forms"
    ]
  },
  {
    "id": 11,
    "question": "Что делает метод `setState` и почему он асинхронный?",
    "answer": "`setState` обновляет состояние компонента и планирует повторный рендер. Он асинхронный для оптимизации: React группирует несколько вызовов в одно обновление, чтобы избежать лишних ререндеров. Для выполнения кода после обновления используйте коллбэк: `setState({ value }, () => console.log('Updated'))`.",
    "category": "React",
    "level": "junior",
    "tags": [
      "state",
      "core"
    ]
  },
  {
    "id": 12,
    "question": "Как работают хуки (hooks) в React? Назовите основные правила их использования.",
    "answer": "Хуки (например, `useState`, `useEffect`) позволяют использовать состояние и другие возможности React без классов. Правила: 1) Вызывать хуки только на верхнем уровне (не в циклах/условиях). 2) Использовать только в функциональных компонентах или кастомных хуках. 3) Называть хуки в одном порядке при каждом рендере.",
    "category": "React",
    "level": "junior",
    "tags": [
      "hooks",
      "modern"
    ]
  },
  {
    "id": 13,
    "question": "Что такое React Fragments и зачем они нужны?",
    "answer": "Фрагменты (`<></>` или `<React.Fragment>`) позволяют группировать элементы без добавления лишнего DOM-узла. Решают проблему, когда компонент должен возвращать несколько соседних элементов (например, список `<td>` в таблице), но JSX требует одного корневого элемента.",
    "category": "React",
    "level": "junior",
    "tags": [
      "jsx",
      "performance"
    ]
  },
  {
    "id": 14,
    "question": "Как оптимизировать производительность в React-приложениях?",
    "answer": "1) `React.memo` для мемоизации компонентов. 2) `useMemo`/`useCallback` для кеширования вычислений и функций. 3) Виртуализация длинных списков (например, react-window). 4) Код-сплиттинг через `React.lazy`. 5) Избегать лишних ререндеров через правильные зависимости в `useEffect`.",
    "category": "React",
    "level": "middle",
    "tags": [
      "performance",
      "optimization"
    ]
  }
]